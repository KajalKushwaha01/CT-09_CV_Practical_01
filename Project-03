
import cv2
import numpy as np
import argparse

def detect_and_match(img1, img2, nfeatures=2000):
    orb = cv2.ORB_create(nfeatures)
    k1, d1 = orb.detectAndCompute(img1, None)
    k2, d2 = orb.detectAndCompute(img2, None)

    if d1 is None or d2 is None:
        return [], [], [], []

    bf = cv2.BFMatcher(cv2.NORM_HAMMING, crossCheck=False)
    matches = bf.knnMatch(d1, d2, k=2)

    good = []
    for m_n in matches:
        if len(m_n) != 2:
            continue
        m, n = m_n
        if m.distance < 0.75 * n.distance:
            good.append(m)

    pts1 = np.float32([k1[m.queryIdx].pt for m in good])
    pts2 = np.float32([k2[m.trainIdx].pt for m in good])

    return pts1, pts2, k1, k2, good

def estimate_models(pts1, pts2):
    results = {}

    if len(pts1) < 3:
        return results

    displ = pts2 - pts1
    median_disp = np.median(displ, axis=0)
    T = np.array([[1, 0, median_disp[0]],
                  [0, 1, median_disp[1]]], dtype=np.float64)
    results['translation'] = T

    M_partial, inliers_partial = cv2.estimateAffinePartial2D(pts1, pts2, method=cv2.RANSAC, ransacReprojThreshold=3.0, maxIters=2000)
    if M_partial is not None:
        results['affine_partial'] = (M_partial, inliers_partial)

    M_affine, inliers_affine = cv2.estimateAffine2D(pts1, pts2, method=cv2.RANSAC, ransacReprojThreshold=3.0, maxIters=2000)
    if M_affine is not None:
        results['affine'] = (M_affine, inliers_affine)

    if len(pts1) >= 4:
        H, maskH = cv2.findHomography(pts1, pts2, method=cv2.RANSAC, ransacReprojThreshold=4.0, maxIters=2000)
        if H is not None:
            results['homography'] = (H, maskH)

    return results

def warp_and_compute_mse(img1, img2, M, model='affine'):
    h, w = img1.shape[:2]
    if model == 'homography':
        warped = cv2.warpPerspective(img2, M, (w, h))
    else:
        warped = cv2.warpAffine(img2, M, (w, h))

    g1 = cv2.cvtColor(img1, cv2.COLOR_BGR2GRAY) if len(img1.shape)==3 else img1
    gw = cv2.cvtColor(warped, cv2.COLOR_BGR2GRAY) if len(warped.shape)==3 else warped

    mask = (gw > 0) | (g1 > 0)
    diff = (g1.astype(np.float32) - gw.astype(np.float32)) * mask
    mse = np.sum(diff*diff) / max(1, np.sum(mask))
    return warped, mse

def draw_matches(img1, img2, k1, k2, matches):
    mimg = cv2.drawMatches(img1, k1, img2, k2, matches, None, flags=cv2.DrawMatchesFlags_NOT_DRAW_SINGLE_POINTS)
    return mimg

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--img1', required=True)
    parser.add_argument('--img2', required=True)
    args = parser.parse_args()

    img1 = cv2.imread(args.img1)
    img2 = cv2.imread(args.img2)
    if img1 is None or img2 is None:
        print("Error loading images.")
        return

    pts1, pts2, k1, k2, good = detect_and_match(img1, img2)
    print(f"Found {len(good)} good matches.")

    models = estimate_models(pts1, pts2)
    print("Estimated models:", list(models.keys()))

    for name, val in models.items():
        if name == 'translation':
            M = val
            warped, mse = warp_and_compute_mse(img1, img2, M, model='affine')
            print(f"[{name}] median_tx,ty = {M[0,2]:.2f}, {M[1,2]:.2f}  MSE={mse:.2f}")
            cv2.imshow(f"warped_{name}", warped)
        elif name == 'affine_partial':
            M, inliers = val
            warped, mse = warp_and_compute_mse(img1, img2, M, model='affine')
            inlier_count = int(np.sum(inliers)) if inliers is not None else 0
            print(f"[affine_partial] inliers={inlier_count}  MSE={mse:.2f}")
            cv2.imshow("warped_affine_partial", warped)
        elif name == 'affine':
            M, inliers = val
            warped, mse = warp_and_compute_mse(img1, img2, M, model='affine')
            inlier_count = int(np.sum(inliers)) if inliers is not None else 0
            print(f"[affine] inliers={inlier_count}  MSE={mse:.2f}")
            cv2.imshow("warped_affine", warped)
        elif name == 'homography':
            H, maskH = val
            warped, mse = warp_and_compute_mse(img1, img2, H, model='homography')
            inlier_count = int(np.sum(maskH)) if maskH is not None else 0
            print(f"[homography] inliers={inlier_count}  MSE={mse:.2f}")
            cv2.imshow("warped_homography", warped)

    if len(good) > 0:
        mm = draw_matches(img1, img2, k1, k2, good)
        cv2.imshow("matches", mm)
    cv2.waitKey(0)
    cv2.destroyAllWindows()

if __name__ == '__main__':
    main()
